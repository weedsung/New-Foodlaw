---
description:
globs:
alwaysApply: false
---
---
description: FoodLaw Project Development Rules
globs: 
alwaysApply: true
---

## 🔄 레거시 시스템 마이그레이션 규칙 (Legacy Migration Rules)

### 1. 레거시 컴포넌트 관리 체계
- **모든 기존 HTML/CSS/JS 파일** `components/legacy-components/` 폴더에 체계적 보관
- **원본 파일 보존**: 마이그레이션 후에도 참조용으로 완전 보존
- **단계별 마이그레이션**: 점진적 변환으로 안정성 확보

### 2. 레거시 폴더 구조 및 활용

# 프로젝트 개발 규칙 (Project Development Rules)

## 🎨 UI/UX 디자인 시스템 우선순위 (UI Design System Priority)

### 1. shadcn/ui 컴포넌트 시스템 (최우선)
- **기존 shadcn/ui 컴포넌트를 반드시 최우선으로 사용**
- 현재 프로젝트는 **"new-york" 스타일** 적용 중
- **OKLCH 색상 공간** 및 **CSS 변수 기반** 테마 시스템
- **class-variance-authority (cva)** 패턴 엄격 준수

### 2. 스타일링 우선순위 체계
1. **shadcn/ui 컴포넌트 + variants** (최우선)
2. **CSS 변수 기반 의미적 색상** (`bg-primary`, `text-foreground`, `border-input`)
3. **cn() 유틸리티로 확장** (기존 스타일과 조화)
4. **Tailwind CSS 클래스** (shadcn 스타일 보완용)
5. **커스텀 CSS** (절대 최후의 수단)

### 3. shadcn/ui 필수 패턴
```tsx
// ✅ 완벽한 패턴 - cva + variants + cn()
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const componentVariants = cva(
  "base-classes",
  {
    variants: {
      variant: { default: "...", secondary: "..." },
      size: { default: "...", sm: "...", lg: "..." }
    },
    defaultVariants: { variant: "default", size: "default" }
  }
)

function MyComponent({ 
  className, 
  variant, 
  size, 
  ...props 
}: React.ComponentProps<"div"> & VariantProps<typeof componentVariants>) {
  return (
    <div 
      className={cn(componentVariants({ variant, size }), className)}
      {...props}
    />
  )
}

// ❌ 절대 금지 패턴 - 순수 Tailwind 직접 사용
function BadComponent() {
  return <button className="px-4 py-2 bg-blue-500 rounded">Bad</button>
}
```

### 4. 색상 시스템 엄격 준수
- **의미적 색상만 사용**: `primary`, `secondary`, `destructive`, `accent`, `muted`
- **다크테마 자동 대응**: CSS 변수 덕분에 자동 적용
- **OKLCH 색상 공간**: 더 정확한 색상 표현 및 접근성

### 5. 새 shadcn 컴포넌트 설치 가이드
```bash
# 새 컴포넌트 필요 시 (사용자가 직접 실행)
npx shadcn@latest add [component-name]

# 자주 사용되는 컴포넌트들
npx shadcn@latest add card button input select
npx shadcn@latest add dialog sheet dropdown-menu
npx shadcn@latest add table tabs badge alert
```


## 컴포넌트 제거 및 백업 규칙 (Component Removal and Backup Rules)

### 1. 컴포넌트 제거 시 백업 필수
- 컴포넌트를 제거하거나 대체할 때는 **반드시** `components/test-components/` 폴더에 백업
- 원본 파일명을 그대로 유지하여 저장
- 제거 이유와 날짜를 `components/test-components/README.md`에 기록

### 2. 테스트 컴포넌트 폴더 구조
```
components/test-components/
├── README.md (백업 로그 및 관리 가이드)
├── [컴포넌트명].tsx (백업된 컴포넌트들)
└── [기타 백업 파일들]
```

### 3. 백업 파일 명명 규칙
- **기본**: 원본과 동일한 파일명 사용
- **버전 관리**: 필요시 날짜 접미사 추가 (예: `component-20250812.tsx`)
- **설명**: README.md에 백업 사유와 재사용 가능성 명시

### 4. README.md 업데이트 필수사항
각 백업 시 다음 정보 추가:
- 파일명
- 백업 날짜
- 제거/변경 이유
- 향후 재사용 가능성
- 관련 커밋 해시

## 개발 접근 방식 (Development Approach)

### 1. 점진적 개발 (Incremental Development)
- **작은 것부터 시작**: 큰 변경사항을 작은 단위로 분할
- **단계별 적용**: 한 번에 하나의 기능씩 구현 및 테스트
- **즉시 커밋**: 각 단계 완료 후 바로 커밋

### 2. 사용자 중심 피드백 (User-Centered Feedback)
- 각 변경사항 적용 후 사용자 확인 요청
- 피드백 받은 후 다음 단계 진행
- 불필요한 기능은 즉시 제거하고 백업

### 3. 테스트 우선 사고 (Test-First Mindset)
- 모든 변경사항은 실제 브라우저에서 테스트
- 개발 서버가 정상 작동하는지 확인
- 에러 발생 시 즉시 롤백 또는 수정

## 코드 품질 규칙 (Code Quality Rules)

### 1. 컴포넌트 구조
- 각 컴포넌트는 단일 책임 원칙 준수
- Props 인터페이스 명시적 정의
- 재사용 가능한 형태로 설계

### 2. 파일 구조 관리
- 사용하지 않는 import 제거
- 일관된 폴더 구조 유지
- 의미 있는 파일명 사용

### 3. 백업 및 복구
- 삭제된 컴포넌트는 test-components 폴더에서 언제든 복구 가능
- 실험적 변경사항은 별도 브랜치에서 진행
- 안정된 버전은 정기적으로 커밋

## 예시 워크플로우 (Example Workflow)

### 컴포넌트 제거 시:
1. 원본 컴포넌트를 `components/test-components/`로 복사
2. README.md에 백업 정보 기록
3. 메인 코드에서 컴포넌트 제거
4. 기능 테스트 진행
5. 문제없으면 커밋

### 새 기능 개발 시:
1. 작은 단위로 기능 분할
2. 첫 번째 단위 구현
3. 브라우저 테스트
4. 사용자 피드백 확인
5. 커밋 후 다음 단위 진행

이 규칙을 따라 안전하고 체계적인 개발을 진행합니다.

## React/Next.js 개발 규칙 (React/Next.js Development Rules)

### 1. 컴포넌트 작성 규칙
- **모든 컴포넌트는 클라이언트 컴포넌트로 작성** (`"use client"` 지시어 필수)
- **page.tsx에서 params props는 Promise 타입 사용**
- 모든 컴포넌트는 반응형 및 접근성 고려하여 작성

### 2. TypeScript 및 코딩 스타일
- **Early Returns 패턴** 사용
- **명확한 변수명과 함수명** 사용
- **상수 > 함수** 원칙 적용
- **순수 함수(Pure Functions)** 지향
- **불변성(Immutability)** 유지

### 3. 함수형 프로그래밍 원칙
- **변이(Mutation) 방지**
- **Map, Filter, Reduce** 적극 활용
- **컴포지션 패턴** 적용 (상속보다 조합)
- **커링과 부분 적용** 활용

### 4. Tailwind CSS 스타일링
- **Tailwind CSS 우선 사용**
- 기존 디자인 패턴 및 컬러 팔레트 준수
- 조건부 클래스 > 삼항 연산자

### 5. 에러 처리 및 검증
- **사용자 입력 검증** 필수
- **우아한 에러 처리(Graceful Error Handling)**
- **예외보다 에러 반환** 선호

## 패키지 관리 및 도구 (Package Management & Tools)

### 1. 패키지 매니저
- **npm 사용** (다른 패키지 매니저 금지)

### 2. Shadcn-ui 컴포넌트
- 새 컴포넌트 필요 시 설치 명령어 표시
- 예시: `npx shadcn@latest add card`

### 3. 이미지 처리
- **플레이스홀더 이미지**: picsum.photos 스톡 이미지 사용

## 문서화 및 주석 (Documentation & Comments)

### 1. 주석 규칙
- **함수 목적** 주석 작성
- **"왜"를 설명** ("무엇"이 아닌)
- **JSDoc 형식** 사용 (JavaScript/TypeScript)
- **TODO:, FIXME:** 주석으로 버그 처리

### 2. 한글 텍스트 처리
- **UTF-8 인코딩** 확인 필수
- 한글 깨짐 현상 방지 및 수정

## 성능 최적화 (Performance Optimization)

### 1. 최적화 원칙
- **조기 최적화 방지**
- **프로파일링 후 최적화**
- **신중한 최적화**
- **최적화 문서화**

### 2. 테스트 전략
- **핵심 기능 단위 테스트**
- **통합 테스트 및 E2E 테스트** 고려

## 핵심 개발 마인드셋 (Core Development Mindset)

1. **단순성 (Simplicity)**
2. **가독성 (Readability)**  
3. **유지보수성 (Maintainability)**
4. **테스트 가능성 (Testability)**
5. **재사용성 (Reusability)**
6. **함수형 패러다임 (Functional Paradigm)**
7. **실용주의 (Pragmatism)**

## 해결 프로세스 (Solution Process)

### 1. 문제 재정의
- 명확하고 전문적인 프롬프트로 변환

### 2. 분석 및 전략 수립
- 문제점 식별, 해결책 개요 작성, 출력 형식 정의

### 3. 솔루션 개발
- "시니어 개발자로서 [재정의된 프롬프트]를 해결해야 합니다"
- 단계별 목록 작성
- 구체적 솔루션 제시

### 4. 솔루션 검증
- 엣지 케이스 테스트 및 개선

### 5. 최종 결과물 준비
- ASCII 제목
- 문제 요약 및 접근법
- 단계별 솔루션과 코드 스니펫
- 잠재적 개선사항 제시